---
title: "TCR alpha-beta pairing model"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyr)
library(dplyr)
library(data.table)
library(grImport)
library(ggplot2)
library(ggbeeswarm)
library(stringr)
library(parallel)
library(network)
library(bnlearn)
library(ggrepel)
library(scales)
library(latex2exp)
library(Biostrings)
library(cowplot)
#devtools::install_github("MHenderson/funcgeo")
library(funcgeo)
library(gridExtra)

select = dplyr::select

CORES <- 40
CONTACT_DIST <- 5
CONTACT_DIST_CA <- 15
CONTACT_FREQ_THRESHOLD <- 0.75
CONTACT_INF_THRESHOLD <- 0.75
```

## Informatice contact inference

Determining contact map between TRA and TRB chains. Estimating contact, building contact profiles, studying residue distributions/PWMs at contact positions. The most complex and critical part here is to align sequences so we work in the same set of residue coordinates. We'll use IMGT numbering for V until CDR3, then we'll use first 4 and last 4 residues of CDR3 and continue onwards to FR4 with continuous the numbering.

### Numbering

Filter resmarkup to select only FR/CDR. Retain only 4 flanks at each side of CDR3, make CDR3+FR4 numbering continuous. We'll set coordinates to negative before 2nd CYS of CDR3 (having coordinate of 0) and positive onwards, producing `cdr3.start.rel.idx` that we'll use for merging with IMGT.

```{r}
FLANK_SZ <- 4

resmarkup <- fread("data_dump/resmarkup.txt", fill = T) %>%
  filter(startsWith(region.type, "FR") | startsWith(region.type, "CDR")) %>%
  # alternative numbering for CDR3
  group_by(pdb.id, chain.id, region.type) %>%
  mutate(residue.index.l = residue.index - min(residue.index),
         residue.index.lm = max(residue.index.l),
         residue.index.s = pmin(residue.index.l, residue.index.lm - residue.index.l)) %>%
  # remove center of CDR3
  filter(region.type != "CDR3" | residue.index.s < FLANK_SZ) %>%
  select(-residue.index.l, -residue.index.lm, -residue.index.s) %>%
  # set numbering wrt 2nd CYS
  group_by(pdb.id, chain.id, part.after.fr3 = region.type %in% c("CDR3", "FR4")) %>%
  mutate(cdr3.start.rel.idx = rank(residue.index) - 
           ifelse(part.after.fr3, 0, max(residue.index) + 1) - 1) %>%
  ungroup %>%
  select(-part.after.fr3)

# append alleles
resmarkup <- fread("data_dump/general.txt") %>%
  mutate(v.allele = str_split_fixed(allele.info, fixed(":"), 2)[,1]) %>%
  # substitute DV
  mutate(v.allele = ifelse(v.allele == "TRAV29DV5*01", "TRAV29/DV5*01", v.allele)) %>%
  mutate(v.allele = ifelse(v.allele == "TRAV14DV4*01", "TRAV14/DV4*01", v.allele)) %>%
  select(pdb.id, chain.id, complex.species, chain.type, v.allele) %>%
  merge(resmarkup) 
```

Load IMGT data. We'll use the fact that 2nd CYS is numbered 104 to compute `cdr3.start.rel.idx` we'll use for merging.

```{r}
IMGT_2CYS <- 104
IMGT_PHETRP <- IMGT_2CYS + 2 * FLANK_SZ - 1

# load imgt fasta
imgt.raw <- readAAStringSet("data_dump/imgt_dump.fa") %>% as.character

# format
imgt.ids <- str_split_fixed(names(imgt.raw), fixed("|"), n = Inf)
imgt <- data.frame(allele = imgt.ids[,2], complex.species = imgt.ids[,3], 
                   seq = imgt.raw, stringsAsFactors = F) %>%
  mutate(complex.species = ifelse(startsWith(complex.species, "Mus"), "Mouse", "Human"),
         segment = substr(allele, 4, 4), chain = paste0("TR", substr(allele, 3, 3)))
rownames(imgt) <- NULL

get_numbered_aas <- function(seq, segment) {
  if (segment == "V") {
    if (nchar(seq) >= IMGT_2CYS) {
      res <- data.frame(aa=strsplit(seq, "")[[1]], stringsAsFactors = F) %>%
        mutate(imgt.idx = 1:n(), cys2 = imgt.idx == IMGT_2CYS) %>%
        filter(aa != ".") %>%
        mutate(cdr3.start.rel.idx = rank(imgt.idx)) %>%
        mutate(cdr3.start.rel.idx = cdr3.start.rel.idx - cdr3.start.rel.idx[which(cys2)]) %>%
        filter(cdr3.start.rel.idx < FLANK_SZ) %>%
        select(-cys2)
    } else {
      res <- data.frame()
    }
  } else {
    pos <- regexpr("[FW][GA].G", seq)[1]
    res <- data.frame(aa=strsplit(seq, "")[[1]], stringsAsFactors = F) %>%
      mutate(imgt.idx = 1:n() - pos + IMGT_PHETRP,
             cdr3.start.rel.idx = imgt.idx - IMGT_2CYS) %>%
      filter(cdr3.start.rel.idx >= FLANK_SZ)
  }
  
  res
}

# flatten sequences
imgt <- imgt %>%
  group_by(complex.species, allele, segment, chain) %>%
  do(get_numbered_aas(.$seq, .$segment)) %>%
  ungroup
```

Merge together with IMGT numbering

```{r}
resmarkup.i <- resmarkup %>%
  # Add V annotations
  merge(imgt %>% filter(segment == "V") %>%
          mutate(v.allele = allele) %>% select(-segment, -chain, -allele), 
        all.x = T, by = c("complex.species", "v.allele", "cdr3.start.rel.idx")) %>%
  # manually set numbering after 2nd CYS
  group_by(pdb.id, chain.id, part.after.fr3 = region.type %in% c("CDR3", "FR4")) %>%
  mutate(imgt.idx = ifelse(part.after.fr3, rank(residue.index) - 1 + IMGT_2CYS, imgt.idx)) %>%
  ungroup %>%
  select(-part.after.fr3) %>%
  filter(!is.na(imgt.idx))
```

### Loading contact data and merging in the numbering

We'll count residue pairs by closeness $C_\alpha < threshold$ and require that a given residue pair contact directly at least once $d_{closest} < threshold$

```{r}
trab.contacts.real <- fread("data_dump/atomdist.txt") %>%
  filter(dist <= CONTACT_DIST) %>%
  select(pdb.id, chain.id.from, chain.id.to, residue.index.from, residue.index.to) %>%
  mutate(real = T) %>%
  unique

trab.contacts <- fread("data_dump/cadist.txt") %>%
  filter(dist.ca <= CONTACT_DIST_CA) %>%
  select(pdb.id, chain.id.from, chain.id.to, residue.index.from, residue.index.to) %>%
  merge(trab.contacts.real, all.x = T) %>%
  mutate(real = !is.na(real)) %>%
  unique

# symmetrize just in case
trab.contacts <- trab.contacts %>%
  rbind(trab.contacts %>%
          mutate(tmp = chain.id.from, chain.id.from = chain.id.to, chain.id.to = tmp) %>%
          mutate(tmp = residue.index.from, residue.index.from = residue.index.to, residue.index.to = tmp) %>%
          select(-tmp)) %>%
  unique
trab.contacts.tmp <- trab.contacts

# merge from=ALPHA
trab.contacts <- trab.contacts %>%
  merge(resmarkup.i %>%
          filter(chain.type == "TRA") %>%
          mutate(chain.id.from = chain.id, residue.index.from = residue.index, 
                 imgt.idx.from = imgt.idx, #region.type.from = region.type,
                 residue.aa.from = residue.aa, v.allele.from = v.allele) %>%
          select(complex.species, pdb.id, v.allele.from,
                 chain.id.from, residue.index.from, imgt.idx.from, #region.type.from,
                 residue.aa.from))

# merge to=BETA
trab.contacts <- trab.contacts %>%
  merge(resmarkup.i %>%
          filter(chain.type == "TRB") %>%
          mutate(chain.id.to = chain.id, residue.index.to = residue.index, 
                 imgt.idx.to = imgt.idx, #region.type.to = region.type,
                 residue.aa.to = residue.aa, v.allele.to = v.allele) %>%
          select(complex.species, pdb.id, v.allele.to,
                 chain.id.to, residue.index.to, imgt.idx.to, #region.type.to, 
                 residue.aa.to)) #%>%
  #filter(complex.species == "Human")

str(trab.contacts)
str(trab.contacts.tmp)
```

### Contact maps

Plotting contact map

```{r}
CDR1_START <- 27
CDR1_END <- 38
CDR2_START <- 56
CDR2_END <- 65
CDR3_START <- 104
CDR3_END <- 111

trab.contacts.t <- trab.contacts %>% 
  group_by(complex.species) %>% 
  summarise(total = length(unique(pdb.id)))

trab.contacts.s <- trab.contacts %>%
  group_by(complex.species, #region.type.from, region.type.to,
           imgt.idx.from, imgt.idx.to) %>%
  summarise(count = length(unique(pdb.id)), real = any(real)) %>%
  merge(trab.contacts.t) %>%
  group_by(complex.species) %>%
  mutate(freq = count / total) 

trab.contacts.s %>%
  ggplot(aes(x = freq, color = real)) +
  geom_density() +
  facet_wrap(~complex.species) +
  theme_bw()

trab.contacts.s <- trab.contacts.s %>% 
  filter(real)

p1 <- trab.contacts.s %>%
  ggplot(aes(x = imgt.idx.from, imgt.idx.to)) +
  geom_vline(xintercept = CDR1_START, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = CDR1_END, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = CDR2_START, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = CDR2_END, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = CDR3_START,linetype = "dashed", color = "grey") +
  geom_vline(xintercept = CDR3_END,linetype = "dashed", color = "grey") +
  geom_hline(yintercept = CDR1_START, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = CDR1_END, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = CDR2_START, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = CDR2_END, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = CDR3_START,linetype = "dashed", color = "grey") +
  geom_hline(yintercept = CDR3_END,linetype = "dashed", color = "grey") +
  geom_point(aes(color = freq)#cut(freq, breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1))), 
            ) +
  geom_vline(xintercept = (CDR3_START + CDR3_END) / 2, linetype = "dotted", color = "grey") +
  geom_hline(yintercept = (CDR3_START + CDR3_END) / 2, linetype = "dotted", color = "grey") +
  annotate("text", x = (CDR1_START + CDR1_END) / 2, y = 0, label = "CDR1", color = "grey30") +
  annotate("text", x = (CDR2_START + CDR2_END) / 2, y = 0, label = "CDR2", color = "grey30") +
  annotate("text", x = (CDR3_START + CDR3_END) / 2, y = 0, label = "CDR3", color = "grey30") +
  xlab("TRA residue index") + ylab("TRB residue index") +
  scale_color_distiller("Contact frequency", limits = c(0,1),
                       palette = "Blues", direction = 1) +
  #scale_fill_brewer("Contact frequency", palette = "Spectral", direction = -1) +
  theme_bw() +
  facet_wrap(~complex.species) +
  theme(aspect = 1, 
        panel.background = element_rect(fill = "white"),
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        strip.background = element_blank(),
        panel.border = element_rect(colour = "black"))

p1

pdf("fig1.pdf", width = 6, height = 6)
p1
dev.off()
```

Contact profiles for TRA and TRB, Human and Mouse. 

```{r}
trab.contact.profile <- trab.contacts %>%
  group_by(chain = "TRA", complex.species, imgt.idx = imgt.idx.from) %>%
  summarise(contact.count = length(unique(pdb.id))) %>%
  rbind(trab.contacts %>%
          group_by(chain = "TRB", complex.species, imgt.idx = imgt.idx.to) %>%
          summarise(contact.count = length(unique(pdb.id)))) %>%
  merge(trab.contacts.t) %>%
  mutate(contact.freq = contact.count / total)

trab.contact.profile %>%
  ggplot(aes(x = imgt.idx, y = contact.freq)) +
  geom_bar(stat = "identity", fill = "red", alpha = 0.7) +
  geom_vline(xintercept = CDR1_START, linetype = "dashed", color = "black") +
  geom_vline(xintercept = CDR1_END, linetype = "dashed", color = "black") +
  geom_vline(xintercept = CDR2_START, linetype = "dashed", color = "black") +
  geom_vline(xintercept = CDR2_END, linetype = "dashed", color = "black") +
  geom_vline(xintercept = CDR3_START,linetype = "dashed", color = "black") +
  geom_vline(xintercept = CDR3_END,linetype = "dashed", color = "black") +
  geom_vline(xintercept = (CDR3_START+CDR3_END)/2,linetype = "dotted", color = "black") +
  facet_grid(complex.species~chain) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
```

### Positional information

Compare contact frequency and information content across V and J genes. We'll compute position conservation and information from PWMs.

```{r}
# frequencies
pairseq.vj <- fread("data_dump/tcr_ab_pairs.vj.txt")
list(
  pairseq.vj %>%
    filter(startsWith(v.alpha, "TRA")) %>%
    group_by(chain = "TRA", segment = "V", allele = v.alpha) %>%
    summarise(count = sum(count)) %>%
    ungroup %>%
    mutate(sample.freq = count / sum(count)) %>%
    select(-count),
  pairseq.vj %>%
    filter(startsWith(j.alpha, "TRA")) %>%
    group_by(chain = "TRA", segment = "J", allele = j.alpha) %>%
    summarise(count = sum(count)) %>%
    ungroup %>%
    mutate(sample.freq = count / sum(count)) %>%
    select(-count),
  pairseq.vj %>%
    filter(startsWith(v.beta, "TRB")) %>%
    group_by(chain = "TRB", segment = "V", allele = v.beta) %>%
    summarise(count = sum(count)) %>%
    ungroup %>%
    mutate(sample.freq = count / sum(count)) %>%
    select(-count),
  pairseq.vj %>%
    filter(startsWith(j.beta, "TRB")) %>%
    group_by(chain = "TRB", segment = "J", allele = j.beta) %>%
    summarise(count = sum(count)) %>%
    ungroup %>%
    mutate(sample.freq = count / sum(count)) %>%
    select(-count)
) %>% rbindlist %>%
  mutate(complex.species = "Human") -> vj.freq

# Information
contact.info <- imgt %>% 
  filter(endsWith(allele, "*01")) %>%
  mutate(allele = gsub("/DV", "DV", allele)) %>%
  mutate(allele = gsub("\\*01", "", allele))

# compute weights
freq.tmp <- contact.info %>%
  select(complex.species, chain, segment, allele) %>%
  unique %>% 
  filter(chain %in% c("TRA", "TRB")) %>%
  merge(vj.freq, all.x = T) %>%
  mutate(sample.freq = ifelse(is.na(sample.freq), 1, sample.freq)) %>%
  group_by(complex.species, chain, segment) %>%
  mutate(sample.freq = sample.freq / sum(sample.freq))

contact.info <- contact.info %>%
  merge(freq.tmp)

contact.info.s <- contact.info %>%
  group_by(complex.species, chain, segment, imgt.idx, aa) %>%
  summarise(count = n(), count.wt = sum(sample.freq)) %>%
  group_by(complex.species, chain, segment, imgt.idx) %>%
  mutate(freq = count / sum(count), freq.wt = count.wt / sum(count.wt),
         I = 1 + sum(freq * log(freq)) / log(20),
         I.wt = 1 + sum(freq.wt * log(freq.wt)) / log(20)) %>%
  ungroup
```

Overlay contact frequency and information content across TRA,B sequences

```{r}
trab.contact.profile.i <- trab.contact.profile %>%
  merge(contact.info.s %>% 
          select(complex.species, chain, segment, imgt.idx, I, I.wt) %>%
          unique %>%
          mutate(I.wt = ifelse(complex.species == "Mouse", NA, I.wt)), all.y = T) %>%
  mutate(contact.freq = ifelse(is.na(contact.freq), 0, contact.freq))

p2 <- trab.contact.profile.i %>%
  ggplot(aes(x = imgt.idx, y = contact.freq)) +
  geom_bar(stat = "identity", fill = "red", alpha = 0.7) +
  geom_line(aes(y = I), color = "blue") +
  geom_line(aes(y = I.wt), color = "blue", alpha = 0.5) +
  geom_vline(xintercept = CDR1_START, linetype = "dashed", color = "black") +
  geom_vline(xintercept = CDR1_END, linetype = "dashed", color = "black") +
  geom_vline(xintercept = CDR2_START, linetype = "dashed", color = "black") +
  geom_vline(xintercept = CDR2_END, linetype = "dashed", color = "black") +
  geom_vline(xintercept = CDR3_START,linetype = "dashed", color = "black") +
  geom_vline(xintercept = CDR3_END,linetype = "dashed", color = "black") +
  geom_vline(xintercept = (CDR3_START+CDR3_END)/2,linetype = "dotted", color = "black") +
  facet_grid(complex.species~chain) +
  xlab("Residue index") + ylab("Contact frequency / Information") +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = "bottom",
        strip.background = element_blank(),
        panel.border = element_rect(colour = "black"))
p2
```

## Amino acid frequencies at interesting contacts

Plot contact frequency vs information content. We do observe 3 types of contacts: rare with non-conserved residues, frequent with non-conserved residues and frequent with conserved residues. The second type is the most feasible for pairing prediction.

```{r}
p3 <- trab.contact.profile.i %>%
  filter(contact.freq > 0) %>%
  ggplot(aes(x = contact.freq, y = I)) +
  annotate(geom = "rect",
           ymin = -Inf, ymax = CONTACT_INF_THRESHOLD, 
           xmin = CONTACT_FREQ_THRESHOLD, xmax = Inf,
           alpha = 0.2, fill = "red") +
  geom_density2d() +
  geom_point() +
  geom_hline(yintercept = CONTACT_INF_THRESHOLD, linetype = "dashed", color = "red") +
  geom_vline(xintercept = CONTACT_FREQ_THRESHOLD, linetype = "dashed", color = "red") +
  xlab("Contact frequency") +
  ylab("Information") +
  facet_grid(complex.species~chain) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = "bottom",
        strip.background = element_blank(),
        panel.border = element_rect(colour = "black"))

p3
```

```{r}
pdf("fig2.pdf", width = 5, height = 7)
plot_grid(p2, p3, labels = c('a', 'b'), ncol = 1)
dev.off()
```

Build list of contacts from non-degenerate (I < threshold) residues that were frequently observed in alpha-beta contact (freq > threshold). Append amino acid information (**time & memory intensive**)

```{r}
trab.contacts.i <- trab.contacts.s %>%
  ungroup %>%
  merge(trab.contact.profile.i %>% 
          filter(chain == "TRA") %>% 
          mutate(imgt.idx.from = imgt.idx, I.from = I, freq.from = contact.freq) %>%
          select(complex.species, imgt.idx.from, I.from, freq.from)) %>%
  merge(trab.contact.profile.i %>% 
          filter(chain == "TRB") %>% 
          mutate(imgt.idx.to = imgt.idx, I.to = I, freq.to = contact.freq) %>%
          select(complex.species, imgt.idx.to, I.to, freq.to)) %>%
  filter(I.from < CONTACT_INF_THRESHOLD & I.to < CONTACT_INF_THRESHOLD & 
           freq.from > CONTACT_FREQ_THRESHOLD & freq.to > CONTACT_FREQ_THRESHOLD)

contact.aa.pairs <- trab.contacts.i %>%
  merge(imgt %>% 
          filter(chain == "TRA") %>%
          mutate(imgt.idx.from = imgt.idx, allele.from = allele, aa.from = aa) %>% 
          select(complex.species, imgt.idx.from, allele.from, aa.from)) %>%
  merge(imgt %>% 
          filter(chain == "TRB") %>%
          mutate(imgt.idx.to = imgt.idx, allele.to = allele, aa.to = aa) %>% 
          select(complex.species, imgt.idx.to, allele.to, aa.to))
```

### Computing non-randomness of AA pairs at contact positions

Merge contacts to VJ usage data from PairSEQ study, Human only (**time & memory intensive**)

```{r}
contact.aa.pairs.sel <- contact.aa.pairs %>%
  filter(complex.species == "Human", 
         endsWith(allele.to, "*01"),
         endsWith(allele.from, "*01")) %>%
  mutate(allele.from = gsub("*01", "", allele.from, fixed = T),
         allele.to = gsub("*01", "", allele.to, fixed = T)) %>%
  mutate(allele.from = gsub("/DV", "DV", allele.from, fixed = T)) %>%
  ungroup %>%
  as.data.table

str(contact.aa.pairs.sel)

get_contacts <- function(data) {
  data %>%
    mutate(id = 1:n()) %>%
    gather(key = "segment.from", value = "allele.from", v.alpha, j.alpha) %>%
    gather(key = "segment.to", value = "allele.to", v.beta, j.beta) %>%
    select(-segment.from, -segment.to) %>%
    as.data.table %>%
    merge(contact.aa.pairs.sel %>%
            select(allele.from, allele.to, imgt.idx.from, imgt.idx.to, aa.from, aa.to),
          by = c("allele.from", "allele.to"), allow.cartesian = T)
}

#get_contacts("TRAV1-1", "TRAJ10", "TRBV10-3", "TRBJ2-3", 5)
contact.aa.pairseq <- pairseq.vj %>%
  get_contacts()
str(contact.aa.pairseq)
```

Compute AA-AA pair odds for contacts

```{r}
get_contact_odds <- function(data) {
  data %>%
    group_by(imgt.idx.to, imgt.idx.from,
             aa.from, aa.to) %>%
    summarise(count = sum(count)) %>%
    ungroup %>%
    rbind(contact.aa.pairs.sel %>% # add missing contacts
            select(imgt.idx.to, imgt.idx.from,
                   aa.from, aa.to) %>%
            unique %>%
            mutate(count = 0)) %>%
    group_by(imgt.idx.to, imgt.idx.from,
             aa.from, aa.to) %>%
    summarise(count = sum(count)) %>%
    group_by(imgt.idx.to, imgt.idx.from) %>%
    mutate(total = sum(count)) %>%
    group_by(imgt.idx.to, imgt.idx.from, aa.from) %>%
    mutate(total1 = sum(count)) %>%
    group_by(imgt.idx.to, imgt.idx.from, aa.to) %>%
    mutate(total2 = sum(count)) %>%
    ungroup %>%
    mutate(count.e = total2 * as.numeric(total1) / total,
           p = (count + 1) / (total + 1),
           pind = (total1 + 1) / (total + 1) * (total2 + 1) / (total + 1),
           odds = log2((count+1)/(count.e+1)))
}

contact.aa.odds <- contact.aa.pairseq %>%
  get_contact_odds()

mt <- max(contact.aa.odds$total)
p4.sd <- data.frame(count.e = 1:mt) %>%
  mutate(p = count.e / mt,
         count.e.sd = sqrt(mt * p * (1 - p)),
         sd2p = log2(1 + 1.96 * count.e.sd / count.e),
         sd2n = log2(1 - 1.96 * count.e.sd / count.e))

# log2 nO / nE = log2 (nE + SD) / nE = log2 (1 + SD / nE)
 
p4 <- ggplot(contact.aa.odds, aes(x = round(count.e), y = odds)) +
  #geom_point(alpha = 0.3) +
  geom_bin2d(bins = 100) +
  #geom_density2d() +
  geom_path(data = p4.sd, aes(y = sd2p), linetype = "dotted", alpha = 0.7) +
  geom_path(data = p4.sd, aes(y = sd2n), linetype = "dotted", alpha = 0.7) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black", alpha = 0.7) +
  scale_x_log10(TeX("n_E"), 
                labels=trans_format('log10',math_format(10^.x))) + 
  scale_y_continuous(TeX("log_2 n_O / n_E"),
                     limits = c(-2,2)) +
  scale_fill_distiller("Density\n(residue pairs)", palette = "Spectral") +
  theme_bw() +
  theme(#legend.position = "bottom",
        panel.border = element_rect(colour = "black"))
p4

pdf("fig3.pdf", width = 5, height = 4)
p4
dev.off()
```

Append information and contact frequency to odds. Compute Chi2 and mutual information (MI) for contacts, plot them to show that there are both direct and indirect informative contacts. Here indirect means with low contact frequency

```{r}
contact.aa.odds.i <- contact.aa.odds %>%
  merge(trab.contacts.i %>% 
          filter(complex.species == "Human") %>%
          select(imgt.idx.to, imgt.idx.from, 
                 contact.freq.from = freq.from, 
                 contact.freq.to = freq.to,
                 contact.freq = freq,
                 I.from, I.to),
        by = c("imgt.idx.to", "imgt.idx.from"))

contact.aa.odds.s <- contact.aa.odds.i %>%
  group_by(imgt.idx.to, imgt.idx.from, 
           contact.freq.from, contact.freq.to, 
           contact.freq, I.from, I.to) %>%
  summarise(df = (length(unique(aa.from)) - 1) * (length(unique(aa.to)) - 1),
            MI = sum(p * log(p / pind)),
            chisq = sum((count - count.e) ^ 2 / (count.e + 1)),
            p.val = pchisq(chisq, df, lower.tail=F) + 1e-300,
            odds.abs.max = max(abs(odds))) %>%
  ungroup %>%
  mutate(p.val.adj = p.adjust(p.val)) %>%
  arrange(-MI)

contact.aa.odds.s %>%
  head

p5 <- ggplot(contact.aa.odds.s, aes(x = MI, y = chisq, 
                              color = -log10(p.val.adj))) +
  geom_point() +
  geom_smooth(color = "black", linetype = "dashed") +
  scale_color_distiller("-log10\nadjusted Pvalue", palette = "YlGnBu", direction = 1) +
  xlab("Mutual information") + ylab(TeX("$\\chi^2$")) +
  theme_bw()
p5

p6 <- ggplot(contact.aa.odds.s, aes(x = I.from + I.to, y = MI)) +
  geom_point() +
  geom_smooth(color = "blue", linetype = "dashed") +
  xlab("Sum of position information") + ylab("Mutual information") +
  theme_bw()
p6

p7 <- ggplot(contact.aa.odds.s, aes(x = contact.freq, y = MI)) +
  annotate(geom = "rect", 
           xmin = CONTACT_FREQ_THRESHOLD, xmax = Inf,
           ymin = -Inf, ymax = Inf, alpha = 0.2, fill = "red") +
  geom_point() +
  geom_density2d() +
  geom_vline(xintercept = CONTACT_FREQ_THRESHOLD, linetype = "dashed", color = "red") +
  xlab("Residue pair contact frequency") + ylab("Mutual information") +
  theme_bw()
p7

pdf("figS1.pdf", width = 4, height = 8)
plot_grid(p5 + theme(legend.position = "bottom"), 
          p6,
          p7,
          labels = c('a', 'b', 'c'), ncol = 1)
dev.off()
```

An example of indirect and direct contact with high Chi2/MI

```{r}
tbl <- contact.aa.odds.s %>%
  ungroup %>%
  filter(imgt.idx.to == 101) %>%
  select(imgt.idx.from, imgt.idx.to, contact.freq, df, chisq, MI, p.val) %>%
  arrange(-chisq)
tbl
tbl1 <- tbl %>% head(n = 5) %>% select(imgt.idx.from, contact.freq, chisq, MI) %>%
                      mutate(contact.freq = round(contact.freq, 2),
                             chisq = round(chisq, 0),
                             MI = round(MI, 4))
colnames(tbl1) <- c("TRA residue index", "Contact frequency", "ChiSQ", "MI")

p8 <- contact.aa.odds %>%
  filter(imgt.idx.to == 101, imgt.idx.from %in% c(47, 43)) %>%
  mutate(contact.id = paste0(imgt.idx.from, "->", imgt.idx.to)) %>%
  ggplot(aes(x = aa.from, y = aa.to, 
             fill = pmax(pmin(odds, 1.5), -1.5)
             )) +
  geom_tile() +
  facet_grid(.~contact.id, scales = "free", space = "free") +
  scale_fill_distiller(TeX("log_2 n_O / n_E"), palette = "RdBu", limits = c(-1.5, 1.5)) +
  xlab("AA in TRA") + ylab("AA in TRB") +
  theme_bw() +
  theme(aspect = 1, panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        strip.background = element_blank(),
        panel.border = element_rect(colour = "black"))
p8

dps <- contact.aa.odds %>%
  filter(imgt.idx.to == 101, imgt.idx.from %in% c(47, 43)) %>%
  filter((aa.from == "W" & imgt.idx.from == 47) | (aa.from == "H" & imgt.idx.from == 43)) %>%
  select(aa.to, aa.from, odds) %>%
  dcast(aa.to~aa.from)
cor.test(dps$W, dps$H)

p9 <- imgt %>% 
  filter(imgt.idx %in% c(47, 43), 
         chain == "TRA", complex.species == "Human", endsWith(allele, "*01")) %>%
  mutate(imgt.idx = paste0("imgt.idx.from.", imgt.idx)) %>%
  dcast(allele ~ imgt.idx, value.var = "aa") %>%
  #filter(imgt.idx.to.10 == "S", imgt.idx.to.7 == "A") -- TRBV6-4
  group_by(imgt.idx.from.47, imgt.idx.from.43) %>%
  summarise(count = n()) %>%
  ggplot(aes(x = imgt.idx.from.47, y = imgt.idx.from.43, fill = as.factor(count))) +
  geom_tile() +
  geom_tile(data = data.frame(imgt.idx.from.47 = "W", imgt.idx.from.43 = "H"), 
            fill = NA, color = "red") +
  geom_text(aes(label = count)) +
  scale_fill_brewer(guide = F, palette = "YlGnBu") +
  xlab("TRA 47th residue") +
  ylab("TRA 43th residue") +
  theme_bw() +
  theme(aspect = 1,
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = "bottom",
        strip.background = element_blank(),
        panel.border = element_rect(colour = "black"))
p9

pdf("figS2.pdf", width = 5, height = 7)
plot_grid(tableGrob(tbl1, theme = ttheme_minimal()),
          p8, p9,
          labels = c('a', 'b', 'c'), nrow = 3)
dev.off()
```

## Estimating alpha-beta pairing diversity

We will now select the set of contacts with joint frequency >50%, reducing the set of contacts as follows

```{r}
ggplot(contact.aa.odds.s, 
       aes(x = as.factor(imgt.idx.from), 
           y = as.factor(imgt.idx.to), 
           size = contact.freq,
           fill = MI)) +
  geom_point(color = "grey") +
  geom_point(shape = 21, color = "grey") +
  scale_fill_distiller(palette = "YlGnBu", direction = 1, limits = c(0, 0.003)) + 
  scale_size_continuous("Contact\nfrequency", limits = c(0, 1)) +
  xlab("TRA residue index") + ylab("TRB residue index") +
  theme_bw() +
  theme(aspect = 1)

contact.aa.odds.sel <- contact.aa.odds.s %>%
  filter(contact.freq > CONTACT_FREQ_THRESHOLD) %>%
  ungroup

ggplot(contact.aa.odds.sel, 
       aes(x = as.factor(imgt.idx.from), 
           y = as.factor(imgt.idx.to),
           size = contact.freq)) +
  geom_point(data = contact.aa.odds.s, color = "grey") +
  geom_point(aes(fill = MI), shape = 21, color = "grey") +
  scale_fill_distiller("MI", palette = "YlGnBu", direction = 1, limits = c(0, 0.003)) + 
  scale_size_continuous("Contact\nfrequency", limits = c(0, 1)) + 
  xlab("TRA residue index") + ylab("TRB residue index") +
  theme_bw() +
  theme(aspect = 1)

contact.aa.odds.sel %>% .$imgt.idx.from %>% sort %>% unique %>% length
contact.aa.odds.sel %>% .$imgt.idx.to %>% sort %>% unique %>% length
```

### Bayesian analysis

Wide-format data, features and data blocks for training

```{r}
contact.mat.from.v <- contact.aa.pairs.sel %>%
  filter(startsWith(allele.from, "TRAV")) %>%
  select(v.alpha = allele.from, imgt.idx.from, aa.from) %>%
  mutate(imgt.idx.from = paste("TRA", imgt.idx.from, sep = ".")) %>%
  unique %>%
  spread(imgt.idx.from, aa.from, fill = "-") %>%
  unclass %>%
  as.data.frame

contact.mat.from.j <- contact.aa.pairs.sel %>%
  filter(startsWith(allele.from, "TRAJ")) %>%
  select(j.alpha = allele.from, imgt.idx.from, aa.from) %>%
  mutate(imgt.idx.from = paste("TRA", imgt.idx.from, sep = ".")) %>%
  unique %>%
  spread(imgt.idx.from, aa.from, fill = "-") %>%
  unclass %>%
  as.data.frame

contact.mat.to.v <- contact.aa.pairs.sel %>%
  filter(startsWith(allele.to, "TRBV")) %>%
  select(v.beta = allele.to, imgt.idx.to, aa.to) %>%
  mutate(imgt.idx.to = paste("TRB", imgt.idx.to, sep = ".")) %>%
  unique %>%
  spread(imgt.idx.to, aa.to, fill = "-") %>%
  unclass %>%
  as.data.frame 

contact.mat.to.j <- contact.aa.pairs.sel %>%
  filter(startsWith(allele.to, "TRBJ")) %>%
  select(j.beta = allele.to, imgt.idx.to, aa.to) %>%
  mutate(imgt.idx.to = paste("TRB", imgt.idx.to, sep = ".")) %>%
  unique %>%
  spread(imgt.idx.to, aa.to, fill = "-") %>%
  unclass %>%
  as.data.frame

pairseq.vj.ex <- pairseq.vj %>% 
  mutate(id = 1:n(), count = as.integer(count)) %>%
  filter(count > 0)
pairseq.vj.ex.flat <- lapply(pairseq.vj.ex, rep, pairseq.vj.ex$count) %>%
  as.data.frame %>%
  select(-count) %>%
  merge(contact.mat.from.v) %>%
  merge(contact.mat.from.j) %>%
  merge(contact.mat.to.v) %>%
  merge(contact.mat.to.j) %>%
  select(-v.alpha, -j.alpha, -v.beta, -j.beta)
pairseq.vj.ex.flat <- as.data.frame(unclass(pairseq.vj.ex.flat))

features.a <- colnames(pairseq.vj.ex.flat)[startsWith(colnames(pairseq.vj.ex.flat), "TRA")]
features.a.vj <- as.integer(str_split_fixed(features.a, fixed("."), 2)[,2])
bn.data.a <- pairseq.vj.ex.flat[, features.a]
features.b <- colnames(pairseq.vj.ex.flat)[startsWith(colnames(pairseq.vj.ex.flat), "TRB")]
features.b.vj <- as.integer(str_split_fixed(features.b, fixed("."), 2)[,2])
bn.data.b <- pairseq.vj.ex.flat[, features.b]
bn.data.ab <- pairseq.vj.ex.flat %>% select(-id)
```

We assume that **inter**chain interactions carry far less information than **intra**chain interactions. This can be actually proving by building a Bayes network with all residues: hill climbing procedure with BIC score will converge to either disconnected networks for TRA and TRB or a network with a single **inter**chain contact.

```{r}
n0 <- hc(bn.data.ab,
   score = "aic",
   max.iter = 5000, maxp = Inf)

#p10
pdf("figS3.pdf", width = 5, height = 5)
graphviz.plot(n0, layout = "dot",
                groups = features.b,
                highlight = list(nodes = features.b, col = "red"))
dev.off()
```

### Learning TRA-TRB contact network

We will therefore first build a network with all **intra**chain contacts blacklisted

```{r}
allowed.contacts.ab <- contact.aa.odds.sel %>%
  mutate(from = paste("TRA", imgt.idx.from, sep = "."),
         to = paste("TRB", imgt.idx.to, sep = ".")) %>%
  select(from, to) %>%
  unique
allowed.contacts.ab <- allowed.contacts.ab %>%
  rbind(allowed.contacts.ab %>% mutate(tmp = from, from = to, to = tmp) %>% select(-tmp))
all.contacts.ab <- expand.grid(from = c(features.a, features.b),
                            to = c(features.a, features.b)) %>%
  filter(substr(from, 1, 3) != substr(to, 1, 3)) %>%
  merge(allowed.contacts.ab %>% mutate(allowed = T), all.x = T) %>%
  mutate(allowed = ifelse(is.na(allowed), F, T))
disallowed.contacts.ab <- all.contacts.ab %>%
  filter(!allowed) %>%
  select(-allowed)

net.ab.inter <- rsmax2(bn.data.ab,
                       blacklist = list(
                         expand.grid(from = features.a, to = features.a, stringsAsFactors = F),
                         expand.grid(from = features.b, to = features.b, stringsAsFactors = F),
                         disallowed.contacts.ab
                         ) %>% rbindlist,
                       maximize.args = list(score = "aic")
                       )

#p11
pdf("figS4.pdf", width = 5, height = 5)
graphviz.plot(net.ab.inter, layout = "fdp",
              groups = features.b,
              highlight = list(nodes = features.b, col = "red"))
dev.off()
```

Explore learned contacts

```{r}
bn.learned.contacts <- as.data.frame(net.ab.inter$arcs) %>%
  filter(substr(as.character(from), 1, 3) != substr(as.character(to), 1, 3)) %>%
  mutate(imgt.idx.1 = str_split_fixed(from, fixed("."), 2)[,2] %>% as.integer,
         imgt.idx.2 = str_split_fixed(to, fixed("."), 2)[,2] %>% as.integer) %>%
  mutate(imgt.idx.from = ifelse(startsWith(as.character(from), "TRA"), imgt.idx.1, imgt.idx.2),
         imgt.idx.to = ifelse(startsWith(as.character(from), "TRA"), imgt.idx.2, imgt.idx.1),
         rotated = !startsWith(as.character(from), "TRA")) %>%
  select(-imgt.idx.1, -imgt.idx.2)
bn.learned.contacts

contact.aa.odds.bn <- contact.aa.odds.sel %>%
         merge(bn.learned.contacts %>% select(imgt.idx.from, imgt.idx.to, rotated) %>%
                 mutate(bnlearn = 1), all.x = T) %>% 
  mutate(bnlearn = !is.na(bnlearn))

p12 <- ggplot(contact.aa.odds.bn, 
       aes(x = as.factor(imgt.idx.from), 
           y = as.factor(imgt.idx.to),
           size = contact.freq)) +
  geom_point(data = contact.aa.odds.s, color = "grey") +
  geom_point(aes(fill = MI), shape = 21, color = "grey") +
  geom_text_repel(data = contact.aa.odds.bn %>% filter(bnlearn),
            aes(label = paste(imgt.idx.from, ifelse(rotated, "<", ">"), imgt.idx.to)),
            size = 3, color = "red", 
            nudge_x = 2, nudge_y = 2, min.segment.length = 0) +
  scale_fill_distiller("MI", palette = "YlGnBu", direction = 1, limits = c(0, 0.003)) + 
  scale_size_continuous("Contact\nfrequency", limits = c(0, 1)) + 
  xlab("TRA residue index") + ylab("TRB residue index") +
  theme_bw() +
  theme(aspect = 1)
p12
pdf("figS5.pdf", width = 6, height = 6)
p12
dev.off()

bn.fit(net.ab.inter, bn.data.ab, method = "bayes") %>%
  .$TRB.101 %>%
  bn.fit.dotplot() 

contact.aa.odds %>%
  filter(imgt.idx.from == 47, imgt.idx.to == 101) %>%
  mutate(contact.id = paste0(imgt.idx.from, "->", imgt.idx.to)) %>%
  ggplot(aes(x = aa.from, y = aa.to, 
             fill = pmax(pmin(odds, 1.5), -1.5)
             )) +
  geom_tile() +
  facet_wrap(~contact.id, scales = "free") +
  scale_fill_distiller("Log2 odds", palette = "RdBu", limits = c(-1.5, 1.5)) +
  theme_bw()
```

Learn full network

```{r fig.height=14, fig.width=14}
net.ab <- rsmax2(bn.data.ab,
                 restrict = "aracne",
                 whitelist = net.ab.inter$arcs,
                 # whitelist will be excluded from blacklist automatically
                 blacklist = rbind(all.contacts.ab %>% select(-allowed),
                               disallowed.contacts.ab), 
                 maximize.args = list(score = "aic")
                 )


graphviz.plot(net.ab,
              groups = features.b,
              highlight = list(nodes = features.b, col = "red"))

# p13
bn.fit(net.ab, bn.data.ab, method = "bayes") %>%
  .$TRB.101 %>%
  bn.fit.dotplot(main = "") 
pdf("figS6.pdf", width = 5, height = 10)
bn.fit(net.ab, bn.data.ab, method = "bayes") %>%
  .$TRB.101 %>%
  bn.fit.dotplot(main = "", xlab = "", ylab = "TRA101 amino acids") 
dev.off()
```

### Computing pairing information

Create independent networks for TRA and TRB, fit data to them

```{r}
net.a <- empty.graph(features.a)
arcs(net.a) <- net.ab$arcs %>% as.data.frame() %>% 
  filter(substr(from, 1, 3) == "TRA", substr(to, 1, 3) == "TRA") %>%
  mutate(from = as.character(from), to = as.character(to))
net.b <- empty.graph(features.b)
arcs(net.b) <- net.ab$arcs %>% as.data.frame() %>% 
  filter(substr(from, 1, 3) == "TRB", substr(to, 1, 3) == "TRB") %>%
  mutate(from = as.character(from), to = as.character(to))

fit.a <- bn.fit(net.a, bn.data.a, method = "bayes")
fit.b <- bn.fit(net.b, bn.data.b, method = "bayes")
fit.ab <- bn.fit(net.ab, bn.data.ab, method = "bayes")
fit.ab.inter <- bn.fit(net.ab.inter, bn.data.ab, method = "bayes")
```

Computing entropies based on all possible combinations

```{r}
ids.a <- pairseq.vj.ex %>%
  group_by(v.alpha, j.alpha) %>%
  summarise(id = min(id)) %>%
  .$id
uniq.feat.a <- (pairseq.vj.ex.flat %>% filter(id %in% ids.a))[, features.a] %>% unique
ids.b <- pairseq.vj.ex %>%
  group_by(v.beta, j.beta) %>%
  summarise(id = min(id)) %>%
  .$id
uniq.feat.b <- (pairseq.vj.ex.flat %>% filter(id %in% ids.b))[, features.b] %>% unique
uniq.feat.ab <- merge(uniq.feat.a, uniq.feat.b, allow.cartesian = T)

uniq.a.probs <- exp(logLik(fit.a, uniq.feat.a, by.sample = T))
uniq.b.probs <- exp(logLik(fit.b, uniq.feat.b, by.sample = T))
uniq.ab.probs <- exp(logLik(fit.ab, uniq.feat.ab, by.sample = T))
uniq.ab.probs <- uniq.ab.probs[!is.na(uniq.ab.probs) & uniq.ab.probs > 0]

data.frame(
Ha = -sum(uniq.a.probs / sum(uniq.a.probs) * log(uniq.a.probs / sum(uniq.a.probs))),
Hb = -sum(uniq.b.probs / sum(uniq.b.probs) * log(uniq.b.probs / sum(uniq.b.probs))),
Hab = -sum(uniq.ab.probs / sum(uniq.ab.probs) * log(uniq.ab.probs / sum(uniq.ab.probs)))
) %>%
  mutate(deltaH = Hab - Ha - Hb)
```

Goodness of fit for training dataset

```{r}
pairseq.vj.ex.probs <- data.frame(prob.a = logLik(fit.a, bn.data.a, by.sample = T),
                                  prob.b = logLik(fit.b, bn.data.b, by.sample = T),
                                  prob.ab = logLik(fit.ab, bn.data.ab, by.sample = T)) %>%
  mutate(id = 1:n())

p16 <- ggplot(pairseq.vj.ex.probs,
       aes(x = prob.a + prob.b, y = prob.ab)) +
  geom_bin2d(bins = 50) +
  scale_fill_distiller("Density\n(clonotypes)", palette = "Spectral") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "black", alpha = 0.5) +
  scale_x_continuous(TeX("$\\textbf{L}_{\\alpha}(i) +\\textbf{L}_{\\beta}(i)$"), limits = c(-100, 0)) + 
  scale_y_continuous(TeX("$\\textbf{L}_{\\alpha\\beta}(i)$"), limits = c(-100, 0)) +
  theme_bw()
p16

# net <- network(net.ab$arcs, directed=T)
# net %v% "chain" <- substr(network.vertex.names(net), 1, 3)
# ggnet2(net, color = "chain",
#                  edge.color = ifelse(substr(net.ab$arcs[,1], 1, 3) == substr(net.ab$arcs[,2], 1, 3), "grey50", "red"),
#                  mode = "fruchtermanreingold",
#                  label = str_split_fixed(network.vertex.names(net), fixed("."), n = 2)[,2],
#                  arrow.size = 8, arrow.gap = 0.01,
#                  legend.position = "bottom", alpha = 0.5, cex = 0.1) +
#             scale_color_brewer("Chain", palette = "Paired") +
#             theme(aspect = 1)
postscript("p15.ps")
graphviz.plot(net.ab,
              groups = features.b,
              highlight = list(nodes = features.b, col = "red")
              )
dev.off()

"p15.ps" %>% PostScriptTrace
p15.1 <- readPicture("p15.ps.xml")
p15.2 <- p15.1 %>% pictureGrob(exp = 0)
pdf("fig4.pdf", width = 5, height = 7.5)
plot_grid(p15.2 %>% rot(angle = 270),
          p16 + theme(aspect = 1),
          rel_heights = c(1, 0.7),
          labels = c('a', 'b'), ncol = 1)
dev.off()
```

## Exploring outliers in TRA-TRB pairing

### Antigen-specific TCRs

Load data, select epitopes with >=30 paired records

```{r}
remove_allele <- function(x) {
  str_split_fixed(x, "[*,]", 2)[,1]
}

vdjdb.vj <- fread("data_dump/vdjdb_full.txt") %>%
  filter(species == "HomoSapiens", 
         cdr3.alpha != "", cdr3.beta != "",
         v.alpha != "", j.alpha != "",
         v.beta != "", j.beta != "") %>%
  select(v.alpha, j.alpha, cdr3.alpha, v.beta, j.beta, cdr3.beta, antigen.epitope) %>%
  unique %>%
  mutate(v.alpha = remove_allele(v.alpha),
         v.beta = remove_allele(v.beta),
         j.alpha = remove_allele(j.alpha),
         j.beta = remove_allele(j.beta)) %>%
  group_by(antigen.epitope) %>%
  mutate(count = n()) %>%
  ungroup %>%
  filter(count >= 30) %>%
  select(-cdr3.alpha, -cdr3.beta, -count)

vdjdb.vj %>% .$antigen.epitope %>% unique

vdjdb.vj %>% nrow
```

Generate all possible pairings

```{r}
vdjdb.vj.s <- vdjdb.vj %>% select(antigen.epitope.a = antigen.epitope, v.alpha, j.alpha) %>% 
  merge(vdjdb.vj %>% select(antigen.epitope.b = antigen.epitope, v.beta, j.beta),
        allow.cartesian = T) %>%
  mutate(type = ifelse(antigen.epitope.a == antigen.epitope.b, "Shuffled (w)", "Shuffled (b)"))

vdjdb.vj.s1 <- vdjdb.vj.s %>% filter(type == "Shuffled (w)")
vdjdb.vj.s2 <- vdjdb.vj.s %>% filter(type == "Shuffled (b)") %>%
  group_by(antigen.epitope.a, antigen.epitope.b) %>%
  sample_n(10000, replace = T) %>%
  ungroup
unique(vdjdb.vj.s2$v.alpha)

vdjdb.vj.all <- vdjdb.vj %>%
    mutate(antigen.epitope.a = antigen.epitope, 
           antigen.epitope.b = antigen.epitope,
           type = "Real") %>%
    select(-antigen.epitope)
vdjdb.vj.all <- vdjdb.vj.all %>% rbind(vdjdb.vj.s1)
vdjdb.vj.all <- vdjdb.vj.all %>% rbind(vdjdb.vj.s2)
```

Create wide data frame, compute LL based on inter-chain contacts

```{r}
vdjdb.vj.all.wide <- vdjdb.vj.all %>%
  merge(contact.mat.from.v) %>%
  merge(contact.mat.from.j) %>%
  merge(contact.mat.to.v) %>%
  merge(contact.mat.to.j) %>%
  select(-v.alpha, -j.alpha, -v.beta, -j.beta)

vdjdb.vj.all.wide.p <- vdjdb.vj.all.wide
vdjdb.vj.all.wide.p$prob.ab <- logLik(fit.ab.inter, vdjdb.vj.all.wide %>% 
                                        select(-antigen.epitope.a, -antigen.epitope.b, - type), by.sample = T)

p15 <- vdjdb.vj.all.wide.p %>%
  ggplot(aes(x = prob.ab,
             color = type,
             linetype = type)) +
  stat_ecdf() +
  facet_wrap(~antigen.epitope.a) +
  scale_x_continuous(TeX("$\\textbf{L}_{\\alpha\\beta}(i)$")) + ylab("CDF") +
  scale_color_manual("", values = c("red", "black", "orange")) +
  scale_linetype_manual("", values = c("solid", "dashed", "solid")) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        strip.background = element_blank(),
        legend.position = "bottom",
        panel.border = element_rect(colour = "black"))
p15

pdf("fig5.pdf", width = 5, height = 5)
p15
dev.off()
```

Perform the same analysis with obs/exp for contacts (**takes long time, memory-intensive**)

```
vdjdb.vj.all.c <- get_contacts(vdjdb.vj.all)
vdjdb.vj.all.i <- vdjdb.vj.all.c %>% merge(contact.aa.odds %>% 
                                             select(imgt.idx.from, imgt.idx.to,
                                                    aa.from, aa.to, p, odds) %>%
                                             unique,
                                           by = c("imgt.idx.from", "imgt.idx.to",
                                                  "aa.from", "aa.to"))
vdjdb.vj.all.s <- vdjdb.vj.all.i %>%
  group_by(id, type, antigen.epitope.a, antigen.epitope.b) %>%
  summarise(ods.a = max(abs(odds)), odds.m = mean(odds), odds.s = sum(odds))

vdjdb.vj.all.s %>%
  ggplot(aes(x = odds.s,
             color = type,
             linetype = type)) +
  stat_ecdf() +
  facet_wrap(~antigen.epitope.a) +
  scale_x_continuous("LLinter(TRA,TRB)") + ylab("CDF") +
  scale_color_manual(values = c("red", "black", "orange")) +
  scale_linetype_manual(values = c("solid", "dashed", "solid")) +
  theme_bw()

vdjdb.vj.all.s %>%
  ggplot(aes(x = odds.a,
             color = type,
             linetype = type)) +
  stat_ecdf() +
  facet_wrap(~antigen.epitope.a) +
  scale_x_continuous("LLinter(TRA,TRB)") + ylab("CDF") +
  scale_color_manual(values = c("red", "black", "orange")) +
  scale_linetype_manual(values = c("solid", "dashed", "solid")) +
  theme_bw()

vdjdb.vj.all.s1 <- vdjdb.vj.all.i %>%
  merge(contact.aa.odds.bn %>% filter(bnlearn == T) %>% select(imgt.idx.from, imgt.idx.to),
        by = c("imgt.idx.from", "imgt.idx.to")) %>%
  group_by(id, type, antigen.epitope.a, antigen.epitope.b) %>%
  summarise(odds.a = max(abs(odds)), odds.m = mean(odds), odds.s = sum(odds))

vdjdb.vj.all.s1 %>%
  ggplot(aes(x = odds.s,
             color = type,
             linetype = type)) +
  stat_ecdf() +
  facet_wrap(~antigen.epitope.a) +
  scale_x_continuous("LLinter(TRA,TRB)") + ylab("CDF") +
  scale_color_manual(values = c("red", "black", "orange")) +
  scale_linetype_manual(values = c("solid", "dashed", "solid")) +
  theme_bw()

vdjdb.vj.all.s1 %>%
  ggplot(aes(x = odds.a,
             color = type,
             linetype = type)) +
  stat_ecdf() +
  facet_wrap(~antigen.epitope.a) +
  scale_x_continuous("LLinter(TRA,TRB)") + ylab("CDF") +
  scale_color_manual(values = c("red", "black", "orange")) +
  scale_linetype_manual(values = c("solid", "dashed", "solid")) +
  theme_bw()
```

## T-cell subsets

MAIT: TRAV1-2/TRAJ12/20/33
iNKT: Va24-Ja18 paired with Vb11
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5789419/

MAIT:
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3804952/

```{r}
inv.tcrs.vj <- data.frame(v.alpha = c("TRAV1-2",
                                      "TRAV1-2",
                                      "TRAV1-2",
                                      "TRAV1-2",
                                      "TRAV1-2",
                                      "TRAV1-2"),
                          j.alpha = c("TRAJ12",
                                      "TRAJ12",
                                      "TRAJ20",
                                      "TRAJ20",
                                      "TRAJ33",
                                      "TRAJ33"),
                          v.beta = c("TRBV20",
                                     "TRBV6-4",
                                     "TRBV20",
                                     "TRBV6-4",
                                     "TRBV20",
                                     "TRBV6-4"))

inv.tcrs.v <- data.frame(v.alpha = c("TRAV1-2",
                                     "TRAV1-2"),
                         v.beta = c("TRBV20",
                                    "TRBV6-4"))

contact.aa.inv <- pairseq.vj %>%
  merge(inv.tcrs.vj) %>% 
  mutate(subset = "vj.mait") %>%
  rbind(pairseq.vj %>%
          merge(inv.tcrs.v) %>% 
          mutate(subset = "v.mait")) %>%
  group_by(subset) %>%
  do(get_contacts(.))

contacts.aa.inv.s <- contact.aa.inv %>%
  group_by(subset, imgt.idx.from, imgt.idx.to) %>%
  mutate(total = sum(count)) %>%
  group_by(subset, imgt.idx.from, imgt.idx.to, total, aa.from, aa.to) %>%
  summarise(count = sum(count))

contacts.aa.inv.odds <- contacts.aa.inv.s %>%
  group_by(imgt.idx.from, imgt.idx.to) %>%
  mutate(total.vj = total[which(subset == "vj.mait")][1],
         total.v = total[which(subset == "v.mait")][1]) %>%
  group_by(imgt.idx.from, imgt.idx.to, aa.from, aa.to, total.vj, total.v) %>%
  summarise(count.vj = ifelse(sum(which(subset == "vj.mait")) == 0, 0,
                              count[which(subset == "vj.mait")]),
            count.v = count[which(subset == "v.mait")]) %>%
  mutate(odds = log2((count.vj + 1) / (total.vj + 1) / (count.v + 1) * (total.v + 1)))

contacts.aa.inv.odds.m <- contacts.aa.inv.odds %>%
  merge(bn.learned.contacts %>% select(imgt.idx.from, imgt.idx.to)) %>%
  merge(contact.aa.odds %>%
          select(imgt.idx.from, imgt.idx.to, aa.from, aa.to, odds.all = odds))

contacts.aa.inv.odds.m %>%
  filter(count.vj > 100) %>%
  arrange(-odds) %>%
  head

p16 <- contacts.aa.inv.odds.m %>%
  filter(count.vj > 100) %>%
  ggplot(aes(x = odds.all, y = odds, color = abs(odds) > 0.1)) +
  geom_point(size = 2) +
  geom_text_repel(data = contacts.aa.inv.odds.m %>% 
                    filter(abs(odds) > 0.1 & count.vj > 100) %>%
                    mutate(lbl = paste0(imgt.idx.from, "(", aa.from,
                                        "):", imgt.idx.to, "(", aa.to, ")")),
                  aes(label = lbl), 
                  min.segment.length = 0, force = 4, segment.alpha = 0.5, nudge_y = 0.1) +
  #geom_density_2d(data = contact.aa.odds, color = "black", linetype = "dashed") +
  scale_y_continuous(TeX("$log_2 \\frac{P(V_{\\alpha}^{MAIT}J_{\\alpha}^{MAIT}V_{\\beta}^{MAIT})}{ P( V_{\\alpha}^{MAIT}J_{\\alpha}^{any}V_{\\beta}^{MAIT}$)}"), limits = c(-0.5, 0.5)) +
  scale_x_continuous(TeX("$log_2 n_O^{any} / n_E^{any}$"), limits = c(-0.5, 0.5)) +
  #scale_size_continuous(TeX("Number of cells, log_2"), 
  #                      breaks = c(1, 3, 5), range = c(1/3, 7/3)) +
  scale_color_manual(guide = F, values = c("grey20", "red")) +
  theme_bw() +
  theme(aspect = 1, legend.position = "bottom")
p16
pdf("fig6.pdf", width = 4, height = 4)
p16
dev.off()
```

## Euler angles and contacts

Load principal axes data, 

```{r}
general <- fread("data_dump/general.txt") %>%
  filter(complex.species == "Human") %>%
  group_by(pdb.id) %>%
  mutate(complex.mhc.class = ifelse(any(chain.supertype == "MHCI"), "MHCI", "MHCII"))
praxis <- fread("data_dump/praxis.txt") %>%
  merge(general)
```

```
should_reflect <- function(x, y, z) {
  #v <- c(x, y, z)
  #m <- max(abs(v))
  #return(v[which(abs(v) == m)] < 0)
  return(x+y+z < 0)
}

praxis <- praxis %>%
  mutate(reflect = should_reflect(x, y, z)) %>%
  mutate(x = ifelse(reflect, -x, x), 
         y = ifelse(reflect, -y, y),
         z = ifelse(reflect, -z, z))
```

Compute euler angles for all pairs of entities

```{r}
calc_euler_angles <- function(pr1obs, pr2obs, pr3obs, pr1, pr2, pr3) {
  pr3proj3 <- pr3 %*% pr3obs
  pr3proj2 <- pr3 %*% pr2obs
  pr2proj3 <- pr2 %*% pr3obs
  
  denom <- sqrt(1 - pr3proj3 * pr3proj3)
  alpha <- acos(-pr3proj2 / denom)
  beta <- acos(pr3proj3)
  gamma <- acos(pr2proj3 / denom)
  
  data.frame(alpha = alpha, beta = beta, gamma = gamma)
}

calc_tb_angles <- function(pr1obs, pr2obs, pr3obs, pr1, pr2, pr3) {
  pr1proj3 <- pr1 %*% pr3obs
  pr1proj2 <- pr1 %*% pr2obs
  pr2proj3 <- pr2 %*% pr3obs
  
  denom <- sqrt(1 - pr1proj3 * pr1proj3)
  psi <- asin(pr1proj2 / denom)
  theta <- asin(-pr1proj3)
  phi <- asin(pr2proj3 / denom)
  
  data.frame(psi = psi, theta = theta, phi = phi)
}

praxis.m <- praxis %>%
  filter(startsWith(vector.type, "PR")) %>%
  select(pdb.id, complex.species, complex.mhc.class, chain.type, vector.type, x, y, z) %>%
  melt() %>%
  mutate(variable = paste(vector.type, variable, sep = ".")) %>%
  dcast(pdb.id + complex.species + complex.mhc.class + chain.type ~ variable, value.var = "value")

praxis.m2 <- praxis.m %>%
  merge(praxis.m, by = c("pdb.id", "complex.species", "complex.mhc.class"),
        suffixes = c(".obs",".proj"))

praxis.s <- praxis.m2 %>%
  filter(chain.type.obs != chain.type.proj) %>%
  group_by(pdb.id, complex.species, complex.mhc.class, chain.type.obs, chain.type.proj) %>%
  do(calc_euler_angles(c(.$PR1.x.obs, .$PR1.y.obs, .$PR1.z.obs),
                       c(.$PR2.x.obs, .$PR2.y.obs, .$PR2.z.obs),
                       c(.$PR3.x.obs, .$PR3.y.obs, .$PR3.z.obs),
                       c(.$PR1.x.proj, .$PR1.y.proj, .$PR1.z.proj),
                       c(.$PR2.x.proj, .$PR2.y.proj, .$PR2.z.proj),
                       c(.$PR3.x.proj, .$PR3.y.proj, .$PR3.z.proj))) %>%
  ungroup %>%
  filter(chain.type.obs %in% c("TRA", "TRB"),
         chain.type.proj %in% c("TRA", "TRB"))
```

```{r}
cont5050 <- trab.contacts %>%
  filter(imgt.idx.from == 50,
         imgt.idx.to == 50) %>%
  merge(praxis.s) %>%
  filter(chain.type.obs == "TRA") %>%
  mutate(residue.aa.to = ifelse(residue.aa.to == "P", "P", "other"))

p17 <- cont5050 %>%
  ggplot(aes(x = alpha / pi * 180, y = gamma / pi * 180, color = residue.aa.to)) +
  geom_point(size = 2) +
  geom_text_repel(data = cont5050 %>%
                    filter(residue.aa.to == "P"),
                  aes(label = str_split_fixed(pdb.id, "_", 2)[,1]),
                  min.segment.length = 0, force = 4, segment.alpha = 0.5, nudge_y = 0.1) +
  scale_color_brewer(TeX("$\\beta_{50}$ residue"), palette = "Set1") +
  xlab(TeX("$\\alpha_{Euler}$")) +
  ylab(TeX("$\\gamma_{Euler}$")) +
  theme_bw() +
  theme(legend.position = "bottom") +
  ggtitle(TeX("$\\alpha_{50}\\rightarrow\\beta_{50}$"))

t.test((cont5050 %>% filter(residue.aa.to == "P") %>% .$alpha) / pi * 180,
       (cont5050 %>% filter(residue.aa.to != "P") %>% .$alpha) / pi * 180)

p17
pdf("fig7a.pdf", width = 4.5, height = 4.5)
p17
dev.off()
```

```{r}
cont10855 <- trab.contacts %>%
  filter(imgt.idx.from == 108,
         imgt.idx.to == 55) %>%
  merge(praxis.s) %>%
  filter(chain.type.obs == "TRA") %>%
  mutate(residue.aa.from = ifelse(residue.aa.from == "N", "N",
                                   ifelse(residue.aa.from == "I", "I", "other")))

p18 <- cont10855 %>%
  ggplot(aes(x = alpha / pi * 180, y = gamma / pi * 180, color = residue.aa.from)) +
  geom_point(size = 2) +
  geom_text_repel(data = cont10855 %>%
                    filter(residue.aa.from %in% c("N", "I")),
                  aes(label = str_split_fixed(pdb.id, "_", 2)[,1]),
                  min.segment.length = 0, force = 4, segment.alpha = 0.5, nudge_y = 0.1)+
  scale_color_brewer(TeX("$\\alpha_{108}$ residue"), palette = "Set1") +
  xlab(TeX("$\\alpha_{Euler}$")) +
  ylab(TeX("$\\gamma_{Euler}$")) +
  theme_bw() +
  theme(legend.position = "bottom") +
  ggtitle(TeX("$\\alpha_{108}\\rightarrow\\beta_{55}$"))

t.test((cont10855 %>% filter(residue.aa.from == "N") %>% .$gamma) / pi * 180,
       (cont10855 %>% filter(residue.aa.from == "I") %>% .$gamma) / pi * 180)

p18
pdf("fig7b.pdf", width = 4.5, height = 4.5)
p18
dev.off()
```


```{r}
library(plot3D)
praxis.arrow <- praxis %>%
  filter(chain.component == "TCR") %>%
  group_by(pdb.id, chain.id) %>%
  mutate(offset.x = x[which(vector.type == "CM")],
         offset.y = y[which(vector.type == "CM")],
         offset.z = z[which(vector.type == "CM")],
         pr1.scale = x[which(vector.type == "I")],
         pr2.scale = y[which(vector.type == "I")],
         pr3.scale = z[which(vector.type == "I")],
         pr.total = pr1.scale + pr2.scale + pr3.scale) %>%
  filter(startsWith(vector.type, "PR")) %>%
  mutate(scale = 10 * ifelse(vector.type == "PR1", pr1.scale / pr.total, 
                        ifelse(vector.type == "PR2", pr2.scale / pr.total, pr3.scale / pr.total))) %>%
  mutate(x1 = x * scale + offset.x, y1 = y * scale + offset.y, z1 = z * scale + offset.z,
         x0 = offset.x, y0 = offset.y, z0 = offset.z) %>%
  ungroup

with(praxis.arrow %>% filter(vector.type == "PR1"), 
     arrows3D(x0, y0, z0, x1, y1, z1, colvar = as.integer(as.factor(chain.type)),# col = cols,
              lwd = 2, d = 3, #clab = c("Quality", "score"), 
              phi = 15, theta = 180, 
              alpha = 0.3,
              main = "Arrows 3D", bty ="g", ticktype = "detailed", type = "simple"))

with(praxis.arrow %>% filter(vector.type == "PR2"), 
     arrows3D(x0, y0, z0, x1, y1, z1, colvar = as.integer(as.factor(chain.type)),# col = cols,
              lwd = 2, d = 3, #clab = c("Quality", "score"), 
              phi = 15, theta = 180, 
              alpha = 0.3,
              main = "Arrows 3D", bty ="g", ticktype = "detailed", type = "simple"))
```

```{r}
#

```